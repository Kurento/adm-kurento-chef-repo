Jenkins Job Creator

In the infrastructure of Kurento jenkins has an important role:
  * It **verifies** thet all changes build and pass their tests
  * It deploys new SNAPSHOT artifacts every time the develop branch is updated. It checks again that all tests passes, but might perform additional checks, such as warning if the downstream projects break and no version bump has been performed.
  * (In the future) It might deploy release artifacts every time the master branch is updated with the appropriate tag. Extra checks for releases will be performed at this step

For this reason having the right job configuration in jenkins is a crucial part of the project as a whole.
Given the growing number of project we are already maintaining, this script serves for the automation of the creation of jenkins job configuration.

The tool we are developing here is a simple script, that will be used like this:

<pre>
$ create_jobs.py project_name project_type  [--features project_features] [--dir <target_dir>]
</pre>

where:
  * *project_name*> is the name of the project we are building jobs for
  * *project_type* is one of @maven@, @build.sh@
  * *project_features* is a comma separated list of features such as @arquillian@, @emulator@, ...
  * *target_dir* is the base directory where the config.xml file will be written.
    By default @../../jobs@ is used as base, as the project is assumed to be invoked
    from the @~jenkins/tools/jenkins-job-creator@ directory. Files are written in @../jobs/${project_name/\//_}{,\\,merged,\\,releases\}/config.xml@


By default @../jobs/${project_name/\//_}@ is used for _plain_ jobs,
@../jobs/${project_name/\//_},merged@ for _merged_ jobs,
@../jobs/${project_name/\//_},releases@ for _release_ jobs.

Features are optional configurations. Executing @create_jobs.py@ on its own will show a current list of those.

h2. Design

We use a template format for the configuration. The template substitutes a small number
of features depending on variables.

Characteristics:
  * we need to include conditionally different fragments depending on build type, _plain_ vs _merged_
    (or hypothetically _release_)
  * we need to add fragments depending of features

Both characteristics can be attained with a simple conditional. We will use the xml comment syntax, slightly extended: @<!--{var}text1-!-text2{var}-->@. This means *use* @text1@ if *feature* @var@ is present, *else* use @text2@.



**NOTES**:
  * To reload jenkins configuration on a running jenkins:
    <pre>
	java -jar /usr/share/jenkins/cli/java/cli.jar -s http://127.0.0.1:9097/jenkins/ reload-configuration
    </pre>
    FIXME, solve the authentication and SSL certificate issues.
  * <pre>
      $ grep -E "{\w+}-->" create_jobs.py | sed -re "s@.*\{(\w+)\}-->.*@\1@" | grep -v feature_name | sort -u
    </pre>
    lists the feature keywords used to selectively comment sections in config-plain.xml
  * The differences between *plain* and *merged* jobs are:
    * @<refspec>refs/changes/*:refs/changes/*</refspec>@ changes to @<refspec></refspec>@,
      so that the regular branches are retrieved
    * @<name>$GERRIT_REFSPEC</name>@ changes to @<name>$GERRIT_REFNAME</name>@ (or @develop@).
      This is because of the variable names in Gerrit events. @$GERRIT_REFNAME@ will be @master@
      for the _release_ jobs
    * <triggerOnEvents>
        <com.sonyericsson.hudson.plugins.gerrit.trigger.hudsontrigger.events.PluginPatchsetCreatedEvent/>
        <com.sonyericsson.hudson.plugins.gerrit.trigger.hudsontrigger.events.PluginDraftPublishedEvent/>
      </triggerOnEvents> instead of 
      <triggerOnEvents>
        <com.sonyericsson.hudson.plugins.gerrit.trigger.hudsontrigger.events.PluginRefUpdatedEvent/>
      </triggerOnEvents>
    * mvn goals changes from @verify@ to @deploy@
    * For sonar, @<branch></branch>@ changes to @<branch>$GERRIT_REFNAME</branch>@, so that Sonar tracks separately the develop branch from tentative changesets.
